import math
import pygame


class BallHandler:
    """A class that handles ball movement on the field

    Attributes:
        ball: The ball on the field
        field: The actual field
        x_speed, y_speed: Set to determine the speed at which the ball moves
        x_moves, y_moves: Determines how far the ball has travelled on each shot
        total_trip, shot_power: Used to calculate the distance the ball has to travel
        ball_x, ball_y: The coordinates of the ball before each shot
    """

    def __init__(self, ball, field, aim_line, walls):
        """Constructor for the ball handling class that initializes the needed
        variables for moving the ball

        Args:
            ball: The ball at its initial coordinates
            field: The field generated by the Field class
        """
        self.ball = ball
        self.field = field
        self.aim_line = aim_line
        self.x_speed = 0
        self.y_speed = 0
        self.x_moves = 0
        self.y_moves = 0
        self.total_trip = 0
        self.shot_power = 0
        self.ball_x = self.ball.rect.x
        self.ball_y = self.ball.rect.y
        self.walls = walls

    def handle_shot(self):
        """A method to handle the shot.

        Sets ball speed and shot power.
        The total trip needs to be reset on every shot in order to calculate the shot distance.
        """
        click_pos = pygame.mouse.get_pos()
        self.ball_x, self.ball_y = self.ball.rect.x, self.ball.rect.y
        self.x_speed = click_pos[0] - self.ball_x
        self.y_speed = click_pos[1] - self.ball_y
        self.shot_power = math.sqrt(
            self.x_speed**2+self.y_speed**2)*2
        self.total_trip = 0

    def move_ball(self):
        """A method that handles moving the ball.

        x and y coordinates change at different pace based on the shot coordinates.
        This achieves a linear movement for the ball across the field.
        The coordinates are updated based on the direction of the shot.
        If the ball has travelled enough, its speed will be zeroed.
        """
        self.x_moves += abs(self.x_speed)*100
        self.y_moves += abs(self.y_speed)*100

        if self.x_moves > 10000:
            if self.x_speed > 0:
                self.ball.rect.move_ip(1, 0)
            elif self.x_speed < 0:
                self.ball.rect.move_ip(-1, 0)
            self.x_moves = 0
            self.total_trip += 1
        if self.y_moves > 10000:
            if self.y_speed > 0:
                self.ball.rect.move_ip(0, 1)
            elif self.y_speed < 0:
                self.ball.rect.move_ip(0, -1)
            self.y_moves = 0
            self.total_trip += 1

        if self.total_trip >= self.shot_power:
            self.x_speed = 0
            self.y_speed = 0

        self.water_hit()
        self.wall_hit()

    def water_hit(self):
        """A method to check if the ball is in water.

        If the ball hits water, it is returned to its starting position.
        """
        water_hit = self.field.check_water_hits()
        if water_hit:
            self.ball.rect.x = self.ball_x
            self.ball.rect.y = self.ball_y
            self.x_speed = 0
            self.y_speed = 0

    def wall_hit(self):
        """A method to bounce the ball off walls.

        Checks the outer walls manually.
        One cell is 15x15 pixels and the ball is 13x13 pixels.
        """
        wall_hit = self.field.check_wall_hits()
        height, width = self.field.get_dimensions()
        
        ball_x = self.ball.rect.x
        ball_y = self.ball.rect.y
        
        if ball_x == 15 or ball_x == width-28:
            self.x_speed = -self.x_speed
        if ball_y == 15 or ball_y == height-28:
            self.y_speed = -self.y_speed
            
        if self.x_speed > 0:
            for i in self.walls['left']:
                if ball_x+13 in range(i[0]*15, i[0]*15+5) and ball_y in range((i[1]-1)*15, (i[2]+1)*15):
                    self.x_speed = -self.x_speed
                    # print('hit', self.ball.rect, i)
        elif self.x_speed < 0:
            for i in self.walls['right']:
                if ball_x == i[0]*15 and ball_y in range((i[1]-1)*15, (i[2]+1)*15):
                    self.x_speed = -self.x_speed
                    
        if self.y_speed > 0:
            for i in self.walls['top']:
                if ball_y+13 == i[0]*15 and ball_x in range((i[1]-1)*15, (i[2]+1)*15):
                    self.y_speed = -self.y_speed
        elif self.y_speed < 0:
            for i in self.walls['bottom']:
                if ball_y == i[0]*15 and ball_x in range((i[1]-1)*15, (i[2]+1)*15):
                    self.y_speed = -self.y_speed
            
            
        # for i in wall_hit:
        #     print(i.rect)
        # if wall_hit:
        #     self.x_speed = -self.x_speed
        #     self.y_speed = -self.y_speed
        # if wall_hit:
        #     print(wall_hit[0].rect, self.ball.rect)
        #     if wall_hit[0].rect.x == self.ball.rect.x+13:
        #         self.x_speed = -self.x_speed
        #     if wall_hit[0].rect.y == self.ball.rect.y+13:
        #         self.y_speed = -self.y_speed
        
