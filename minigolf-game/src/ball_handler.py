import math
import random
import pygame


class BallHandler:
    """A class that handles ball movement on the field

    Attributes:
        ball: The ball on the field
        field: The actual field
        x_dist, y_dist: The distance from the ball to the mouse click location
        x_moves, y_moves: Determines how far the ball has travelled on each shot
        total_trip, shot_power: Used to calculate the distance the ball has to travel
        ball_x, ball_y: The coordinates of the ball before each shot
    """

    def __init__(self, ball, field, walls):
        """Constructor for the ball handling class that initializes the needed
        variables for moving the ball.

        Args:
            ball: The ball at its initial coordinates
            field: The field generated by the Field class
        """
        self.ball = ball
        self.field = field
        self.x_dist = 0
        self.y_dist = 0
        self.total_trip = 0
        self.shot_power = 0
        self.ball_x, self.ball_y = self.ball.get_coordinates()
        self.hit_ranges = walls
        self.shot_allowed = True
        self.velocity = 100
        self.x_float = 0.0
        self.y_float = 0.0

    def handle_shot(self):
        """A method to handle the shot.

        Sets ball speed and shot power.
        The total trip needs to be reset on every shot in order to calculate the shot distance.
        """
        if self.shot_allowed:
            click_pos = pygame.mouse.get_pos()
            self.ball_x, self.ball_y = self.ball.get_coordinates()
            self.x_dist = (click_pos[0] - (self.ball_x+6))
            self.y_dist = (click_pos[1] - (self.ball_y+6))
            self.shot_power = math.sqrt(
                self.x_dist**2+self.y_dist**2)*2
            self.total_trip = 0
            self.shot_allowed = False
            self.x_float = (abs(self.x_dist)/self.velocity -
                            abs(self.x_dist)//self.velocity)*100
            self.y_float = (abs(self.y_dist)/self.velocity -
                            abs(self.y_dist)//self.velocity)*100

    def move_ball(self):
        """A method that handles moving the ball.


        """
        self.ball.move(self.x_dist/self.velocity,
                       self.y_dist/self.velocity)

        checker = random.randint(0, 101)
        if checker < self.x_float:
            if self.x_dist > 0:
                self.ball.move(1, 0)
            elif self.x_dist < 0:
                self.ball.move(-1, 0)
        if checker < self.y_float:
            if self.y_dist > 0:
                self.ball.move(0, 1)
            elif self.y_dist < 0:
                self.ball.move(0, -1)

        self.total_trip += max(abs(self.x_dist/self.velocity),
                               abs(self.y_dist/self.velocity))

        if self.total_trip >= self.shot_power or self.velocity < 1:
            self.x_dist = 0
            self.y_dist = 0
            self.x_float = 0.0
            self.y_float = 0.0
            self.shot_allowed = True

        self.water_hit()
        self.wall_hit()

    def water_hit(self):
        """A method to check if the ball is in water.

        If the ball hits water, it is returned to its starting position.
        """
        water_hit = self.field.check_water_hits()
        if water_hit:
            self.ball.rect.x = self.ball_x
            self.ball.rect.y = self.ball_y
            self.x_dist = 0
            self.y_dist = 0
            self.shot_allowed = True

    def wall_hit(self):
        """A method to bounce the ball off walls.

        Checks the outer walls manually.
        The walls inside the field are checked based on the coordinate
        ranges of the walls.The ranges are modified a bit to take
        into account the usage of the upper left coordinates of the ball.
        A range of wall is only checked if the direction of the ball
        allows the ball to hit the wall from that direction.
        One cell is 15x15 pixels and the ball is 13x13 pixels.
        """
        height, width = self.field.get_dimensions()
        ball_x, ball_y = self.ball.get_coordinates()

        if ball_x <= 15 and self.x_dist < 0:
            self.x_dist = -self.x_dist
        if ball_x >= width-28 and self.x_dist > 0:
            self.x_dist = -self.x_dist
        if ball_y <= 15 and self.y_dist < 0:
            self.y_dist = -self.y_dist
        if ball_y >= height-28 and self.y_dist > 0:
            self.y_dist = -self.y_dist

        if self.x_dist < 0:
            for x_coord, ranges in self.hit_ranges['right'].items():
                if ball_x in range((x_coord+1)*15-2, (x_coord+1)*15):
                    for y_pair in ranges:
                        self.switch_x_direction(y_pair, ball_y)
        if self.x_dist > 0:
            for x_coord, ranges in self.hit_ranges['left'].items():
                if ball_x in range((x_coord-1)*15+2, (x_coord-1)*15+4):
                    for y_pair in ranges:
                        self.switch_x_direction(y_pair, ball_y)
        if self.y_dist < 0:
            for y_coord, ranges in self.hit_ranges['bottom'].items():
                if ball_y in range((y_coord+1)*15-2, (y_coord+1)*15):
                    for x_pair in ranges:
                        self.switch_y_direction(x_pair, ball_x)
        if self.y_dist > 0:
            for y_coord, ranges in self.hit_ranges['top'].items():
                if ball_y in range((y_coord-1)*15+2, (y_coord-1)*15+4):
                    for x_pair in ranges:
                        self.switch_y_direction(x_pair, ball_x)

    def switch_y_direction(self, x_range, ball_x):
        if ball_x in range((x_range[0]-1)*15+4, x_range[1]*15-4):
            self.y_dist = -self.y_dist

    def switch_x_direction(self, y_range, ball_y):
        if ball_y in range((y_range[0]-1)*15+4, y_range[1]*15-4):
            self.x_dist = -self.x_dist
